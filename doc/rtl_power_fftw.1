.\" Automatically generated by Pandoc 2.14.0.3
.\"
.TH "rtl_power_fftw" "1" "" "" ""
.hy
.SH NAME
.PP
rtl_power_fftw - obtain a power spectrum from RTL2832U devices
.SH SYNOPSIS
.PP
rtl_power_fftw [\f[C]OPTION\f[R] \&...]
.SH DESCRIPTION
.PP
\f[C]rtl_power_fftw\f[R] reads the data stream from a RTL2832U device,
performs the Fast Fourier transform on it, converts the frequency-domain
data into a power spectrum and (usually, but not necessarily) averages a
number of such spectra to gain a better signal-to-noise ratio.
The program is capable of continuous real-time data acquisition and
processing: it uses the rtl-sdr library to access the RTL2832U device
and the FFTW library to do the FFT.
Data acquisition and Fast Fourier transform are done in separate program
threads for maximum efficiency.
The resulting power spectrum is written to the standard output.
.PP
Scans of wide frequency ranges are supported: if the range exceeds the
device bandwidth, \f[C]rtl_power_fftw\f[R] can perform the measurement
in multiple steps, changing the central frequency each time so that the
desired frequency range is completely covered.
See \f[B]FREQUENCY SCANNING\f[R] below for details.
.PP
The program can be stopped gracefully by sending the SIGINT signal to it
(pressing Ctrl+C).
If only one such signal is received, the program will finish the current
frequency scan, write out the data and terminate.
This is useful for quitting continuous acquisition mode (see
\f[C]--continue\f[R]) as it ensures that the current scan is finished
before the program stops.
If two SIGINTs are received, the current acquisition will stop as soon
as possible and no attempt will be done to finish the current scan (the
data will still be written out, but some spectra might be missing from
the last frequency scan).
The third SIGINT will signal the operating system to terminate the
program immediately.
.PP
\f[C]rtl_power_fftw\f[R] accepts various options and switches that
determine how the data from the RTL device is acquired and processed.
.SH OPTIONS
.TP
\f[B]\f[CB]-B <file|->\f[B]\f[R], \f[B]\f[CB]--baseline <file|->\f[B]\f[R]
Subtract baseline, read baseline data from a file or from standard
input.
See \f[B]BASELINE AND WINDOW FUNCTION DATA\f[R] below for format and
further considerations.
.TP
\f[B]\f[CB]-b <bins in FFT spectrum>\f[B]\f[R], \f[B]\f[CB]--bins <bins in FFT spectrum>\f[B]\f[R]
Number of bins in the FFT spectrum (must be an even number).
.TP
\f[B]\f[CB]--buffers <buffers>\f[B]\f[R]
Number of read buffers: don\[cq]t touch unless running out of memory.
.TP
\f[B]\f[CB]-c\f[B]\f[R], \f[B]\f[CB]--continue\f[B]\f[R]
Repeat the same measurement endlessly.
The spectra are written sequentially to the output and a header is
appended before each measurement (as usual).
.TP
\f[B]\f[CB]-d <device index>\f[B]\f[R], \f[B]\f[CB]--device <device index>\f[B]\f[R]
RTL-SDR device index of the device used for the measurement.
.TP
\f[B]\f[CB]-e <session duration>\f[B]\f[R], \f[B]\f[CB]--elapsed <session duration>\f[B]\f[R]
Allows to specify the recording duration in hours, sec, mins\&...
.TP
\f[B]\f[CB]-f <Hz|Hz:Hz>\f[B]\f[R], \f[B]\f[CB]--freq <Hz|Hz:Hz>\f[B]\f[R]
Center frequency of the receiver or the frequency range to scan.
A number can be followed by a \f[C]k\f[R], \f[C]M\f[R] or \f[C]G\f[R]
multiplier, meaning that the frequency is expressed in kilohertz,
megahertz or gigahertz.
Frequency range consists of lower and upper bound, separated with colon.
.TP
\f[B]\f[CB]-g <1/10th of dB>\f[B]\f[R], \f[B]\f[CB]--gain <1/10th of dB>\f[B]\f[R]
Receiver gain, expressed in tenths of a decibel (e.g., 100 means 10 dB).
.TP
\f[B]\f[CB]-l\f[B]\f[R], \f[B]\f[CB]--linear\f[B]\f[R]
Calculate linear power values instead of logarithmic.
.TP
\f[B]\f[CB]-m <file name without extension>\f[B]\f[R], \f[B]\f[CB]--matrix <file name without extension>\f[B]\f[R]
Specify a file name (no extension) and use it to store the power values
in binary format within a .bin file plus a metadata text file with .met
extension.
.TP
\f[B]\f[CB]-n <repeats>\f[B]\f[R], \f[B]\f[CB]--repeats <repeats>\f[B]\f[R]
Number of spectra to average (incompatible with \f[C]-t\f[R]).
.TP
\f[B]\f[CB]-o <percent>\f[B]\f[R], \f[B]\f[CB]--overlap <percent>\f[B]\f[R]
Define lower boundary for overlap when frequency hopping (otherwise
meaningless).
.TP
\f[B]\f[CB]-p <ppm>\f[B]\f[R], \f[B]\f[CB]--ppm <ppm>\f[B]\f[R]
Correct for the oscillator error of RTL-SDR device.
The correction should be given in ppm.
.TP
\f[B]\f[CB]-q\f[B]\f[R], \f[B]\f[CB]--quiet\f[B]\f[R]
Limit verbosity.
Allows the various printouts to happen only the first time and not on
every scan.
.TP
\f[B]\f[CB]-P\f[B]\f[R], \f[B]\f[CB]--powerbiast\f[B]\f[R]
Switch the bias-T ON/OFF
.TP
\f[B]\f[CB]-r <Hz>\f[B]\f[R], \f[B]\f[CB]--rate <Hz>\f[B]\f[R]
Sample rate of the receiver in Hz.
.TP
\f[B]\f[CB]-s <bytes>\f[B]\f[R], \f[B]\f[CB]--buffer-size <bytes>\f[B]\f[R]
Size of the read buffers (leave it as it is unless you know what you are
doing).
.TP
\f[B]\f[CB]-T\f[B]\f[R], \f[B]\f[CB]--strict-time\f[B]\f[R]
End measurement when the time set with \f[C]--time\f[R] option is up,
regardless of the number of gathered samples.
.TP
\f[B]\f[CB]-t <seconds>\f[B]\f[R], \f[B]\f[CB]--time <seconds>\f[B]\f[R]
Integration time (incompatible with -n).
This is an \f[I]effective integration time\f[R]; see \f[B]INTEGRATION
TIME\f[R] below for more info (in short, the measurement might take
\f[I]longer\f[R] than that).
.TP
\f[B]\f[CB]-w <file|->\f[B]\f[R], \f[B]\f[CB]--window <file|->\f[B]\f[R]
Use a window function, read data from a file or from standard input.
See \f[B]BASELINE AND WINDOW FUNCTION DATA\f[R] below for format and
further considerations.
.TP
\f[B]\f[CB]--\f[B]\f[R], \f[B]\f[CB]--ignore_rest\f[B]\f[R]
Ignore the rest of the labeled arguments following this flag.
.TP
\f[B]\f[CB]--version\f[B]\f[R]
Display version information and exit.
.TP
\f[B]\f[CB]-h\f[B]\f[R], \f[B]\f[CB]--help\f[B]\f[R]
Display usage information and exit.
.SH OUTPUT FORMAT
.PP
Every spectrum that \f[C]rtl_power_fftw\f[R] writes to stdout is
preceded by a few lines of metadata: these lines begin with a
\f[C]#\f[R] character.
Timestamps of data acquisition start and end are written, followed by a
header line describing the data.
This is an example output:
.IP
.nf
\f[C]
# Acquisition start: 2015-11-22 17:59:34 UTC
# Acquisition end: 2015-11-22 17:59:34 UTC
#
# frequency [Hz] power spectral density [dB/Hz]
1.41940575e+09 -68.7714
1.41940966e+09 -68.668
\&...
\f[R]
.fi
.PP
Data lines contain two columns: the frequency and the power spectral
density.
Note: the power values are expressed in logarithmic (dB) scale, but the
reference power is not explicitly given.
In particular, the numbers are \f[B]NOT\f[R] in dBm; they might be
different for a different device and might also change (shift by a
constant) in future versions of the program.
In other words: don\[cq]t assume anything.
If you need absolute units, you have to calibrate your device against a
known reference signal.
.PP
If several measurements are to be done, the consecutive spectra will be
divided by blank lines (see \f[B]FREQUENCY SCANNING\f[R] for details).
.SH INTEGRATION TIME
.PP
The integration time specified with the \f[C]--time\f[R] option is
usually considered to be the \f[I]effective\f[R] integration time, i.e.,
the total number of samples to be acquired divided by the sample rate.
If all goes well, the program will run for about this long (plus some
overhead for setting up the device etc.).
However, if samples are dropped for any reason (for example, if the CPU
can\[cq]t perform the FFTs quickly enough to cope with the actual data
rate), the program will run for whatever time required to collect the
needed number of samples, which can be considerably longer than the
effective integration time.
.PP
If you need the program to stop after a fixed time \[en] regardless of
the actual number of samples collected \[en] use the
\f[C]--strict-time\f[R] switch.
Be warned, though, that only \f[I]acquisition\f[R] will be stopped after
this time and it can take several more seconds for the FFT of the
remaining data to be performed (this time overhead depends on the number
of buffers used, see \f[B]BUFFERING\f[R] below).
.SH FREQUENCY SCANNING
.PP
If the frequency span is too large to be contained within a single
measurement (i.e., it exceeds the device bandwidth),
\f[C]rtl_power_fftw\f[R] will divide it into several consecutive
measurements.
.PP
Of course, this raises a question: how to go about fitting several
fixed-width (one device bandwidth) measurements into an arbitrary range?
One could go for non-overlapping measurements, which yields data that is
monotonously increasing in frequency, but then the whole scan might need
to start \f[I]below\f[R] the lowest requested frequency, or end
\f[I]above\f[R] the highest requested frequency, or even both.
Even worse, these extended ranges could happen to contain frequencies
not accepted by the device.
Another approach is therefore used, namely to cover the requested
frequency range exactly, but with overlapping measurements.
Note that \f[C]rtl_power_fftw\f[R] will not make any presumptions on
what to do with the overlaps: the overlapping spectra are simply written
to the output and all further data treatment is up to the user.
In case that your particular data treatment requires a certain minimum
amount of overlap, you can use the option \f[C]--overlap\f[R] to set the
desired lower bound for overlap in percentage of bandwidth.
.PP
All spectra within one scan of the desired frequency range are separated
in the output by a single blank line.
After the whole frequency range has been scanned, an additional blank
line is printed, so the measurement \f[I]sets\f[R] are separated by two
blank lines in total.
This output format is directly suitable as an input for
\f[C]gnuplot\f[R].
.SH BASELINE AND WINDOW FUNCTION DATA
.PP
The expected input format for baseline and window function data is one
value per line.
If a line contains multiple values, the last (rightmost) value is used:
this ensures that \f[C]rtl_power_fftw\f[R] can use its own output data
as an input for baseline correction \[en] the frequency column is simply
discarded.
Lines starting with \f[C]#\f[R] are treated as comments and are ignored
completely.
.PP
If both the baseline and window function data are to be read from
standard input, the baseline data is read first, followed by the window
function data.
.PP
The program does not check the window function data in any way, apart
from the requirement to have precisely enough data points.
Window function is only read in single precision, due to FFT being done
with floats, and there is no need to overcomplicate things.
Single precision FFT is faster than double on at least some hardware and
more than precise enough, as input data is actually only 8-bit.
Baseline data is in double precision, otherwise it would limit the
precision of averaging arbitrarily huge number of spectra.
.SH BUFFERING
.PP
Upon starting, the program allocates several data buffers (five by
default).
At any given time, one of the buffers is used to store the incoming data
from the device.
When the buffer fills up, it is queued for processing by the FFT routine
and an empty buffer is immediately taken to continue the data
acquisition; at this point, the number of empty buffers is also recorded
for statistical purposes (see below).
If no buffers are empty, the data acquisition blocks until one of the
buffers becomes available again.
This is, of course, an unwanted scenario because it leads to dropped
data.
.PP
At the end of the measurement, the program outputs a line with the
statistics on the number of available (empty) buffers.
This is an example of such a line:
.IP
.nf
\f[C]
Buffer queue histogram: 0 0 0 6 34 1
\f[R]
.fi
.PP
The numbers report how many times a particular number of available
buffers was encountered.
The first number corresponds to zero available buffers, the next one to
one available buffer and so on.
In this particular case, at least three buffers were available at all
times: three buffers were available on six occurrences, four buffers
were available on 34 occurrences and all five buffers were only
available once (when the program started and there was no data yet).
.PP
As long as the first number remains zero, you are fine - there was no
data loss.
If the first number happens to be nonzero and also exceeds the other
numbers, this means that your CPU is too slow and cannot perform the
FFTs quickly enough to match the incoming data rate.
You might be better off with a smaller FFT size or a slower sampling
rate.
.PP
On the contrary, if the first number is nonzero but is relatively small
compared to the other numbers, it might simply mean that the available
CPU power fluctuates heavily (e.g., if you have a fast processor but
other CPU-intensive tasks are running at the same time).
In such a case, you can try increasing the number of buffers with the
\f[C]--buffers\f[R] option and see if that helps.
.PP
Another scenario occurs if you have enough computing power but the
memory is limited: in such a (rare) case, you might actually want to
\f[I]reduce\f[R] the number of buffers.
.PP
The size (length) of the buffers is computed automatically to best match
the requirements of the measurement.
This is the recommended practice in most circumstances.
However, if you feel that you have a very good reason to fiddle with the
buffer size, you can do so with the \f[C]--buffer-size\f[R] option.
But do keep in mind that the buffer size should be a multiple of 16384
(this is a requirement of the rtl-sdr library).
.SH EXAMPLES
.PP
A basic call to \f[C]rtl_power_fftw\f[R] might look like this:
.IP
.nf
\f[C]
rtl_power_fftw -f 1420405752 -t 10 -b 512 > spectrum.dat
\f[R]
.fi
.PP
This will set the central frequency of the receiver to 1420405752 Hz
(the frequency of the hydrogen line), use a 512-point FFT to transform
the acquired signal, average the data for ten seconds and dump the
averaged spectrum to a file named \f[I]spectrum.dat\f[R].
.PP
By the virtue of the output data being suitable for direct use in
\f[C]gnuplot\f[R], the following pipeline can be used to acquire a
spectrum and draw it into a PNG image (for variety, the \f[C]-n\f[R]
option is used this time to request the average of 100 spectra):
.IP
.nf
\f[C]
rtl_power_fftw -f 1420405752 -n 100 -b 512 |\[rs]
   gnuplot -e \[dq]set term png; unset key; plot \[aq]-\[aq] w l\[dq] >plot.png
\f[R]
.fi
.PP
For quick-and-dirty live monitoring, you can do:
.IP
.nf
\f[C]
rtl_power_fftw -f 1420405752 -n 100 -b 512 -c |\[rs]
   sed -u \[aq]/rtl-power-fftw/s/.*/plot \[dq]-\[dq]/;/\[ha]$/{N;s/\[ha]\[rs]n$/e/}\[aq] |\[rs]
   gnuplot
\f[R]
.fi
.PP
In this pipeline, \f[C]sed\f[R] intervenes by replacing the header and
separators written by \f[C]rtl_power_fftw\f[R] with inline commands for
\f[C]gnuplot\f[R].
.PP
To scan frequencies between 100 MHz and 110 MHz and subtract baseline
data from each scan, you could do:
.IP
.nf
\f[C]
rtl_power_fftw -f 100M:110M -B baseline_data.dat > spectrum.dat
\f[R]
.fi
.PP
This example also illustrates the fact that for all the options where it
is possible, the program selects some safe default values and the
options can be omitted.
Although be noted that omiting the option to specify number of bins
(\f[C]-b\f[R]) and relying on its default value while subtracting
baseline is a discouraged practise.
You should always specify \f[C]--bins\f[R] along with
\f[C]--baseline\f[R].
.SH Binary output with metadata
.PP
To scan for 5 minutes, with reduced verbosity and writing a binary file
plus text metafile:
.IP
.nf
\f[C]
rtl_power_fftw -f 144100000:146100000 -b 500 -n 100 -g 350 -p 0 -e 5m -q -m myscanfilename
\f[R]
.fi
.PP
These parameters will produce a myscanfilename.bin binary file and, when
the 5 minutes will be elapsed you will get also myscanfilename.met text
file with this kind of content:
.PP
500 # frequency bins (columns)
.PD 0
.P
.PD
2816 # scans (rows)
.PD 0
.P
.PD
144100000 # startFreq (Hz)
.PD 0
.P
.PD
146096000 # endFreq (Hz)
.PD 0
.P
.PD
4000 # stepFreq (Hz)
.PD 0
.P
.PD
0.025 # effective integration time secs
.PD 0
.P
.PD
0.0557726 # avgScanDur (sec)
.PD 0
.P
.PD
160324152435 # firstAcqTimestamp UTC
.PD 0
.P
.PD
160324152935 # lastAcqTimestamp UTC
.PP
You can use these values for further processing and/or plotting the
binary file content.
The binary file is a continuous stream of float values (4 bytes each).
You get all the columns (the FFT bins) in a scan, one scan after the
other.
This matrix like layout can be easily plotted with gnuplot (or similar)
and has the advantage of keeping minimum file size, maximum precision
and fast rendering.
The average scan duration is calculated across the whole scan session (5
minutes in this case).
The words columns and rows refer to the planned vertical (waterfall)
rendering of the data.
.PP
Binary file size in this case is: 5,632,000 bytes.
.PD 0
.P
.PD
File size is directly influenced by parameters -f -b -n -e .
.SS AUTHORS
.PP
Klemen Blokar <klemen.blokar@ad-vega.si>
.PD 0
.P
.PD
Andrej Lajovic <andrej.lajovic@ad-vega.si>
